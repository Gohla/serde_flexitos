use std::error::Error;
use std::fmt;
use std::fmt::{Debug, Formatter};

use once_cell::sync::Lazy;
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use serde::de::{DeserializeSeed, MapAccess, SeqAccess, Visitor};
use serde::ser::{SerializeMap, SerializeTupleStruct};

use serde_flexitos::{deserialize_trait_object, Registry, serialize_trait_object};
use serde_flexitos::id::{Id, IdObj};

// Task

/// Object-safe task trait.
pub trait Task: erased_serde::Serialize + IdObj + Debug {}

/// Task implementation that returns a constant.
#[derive(Debug)]
pub struct Constant<T>(pub T);
impl<T: Serialize + Id + Debug> Task for Constant<T> {}
impl<T> Id for Constant<T> {
  // TODO: this impl does not actually depend on T, but it must be included, so this does not work.
  const ID: &'static str = "Constant";
}

// Hand-written serialize implementation for Constant.
impl<T: Serialize + Id> Serialize for Constant<T> {
  fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
    struct IdValue<'a, T: Serialize + Id>(&'a T);
    impl<'a, T: Serialize + Id> Serialize for IdValue<'a, T> {
      fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        let mut map = serializer.serialize_map(Some(1))?;
        map.serialize_entry(T::ID, self.0)?;
        map.end()
      }
    }

    let mut ts = serializer.serialize_tuple_struct("Constant", 1)?;
    ts.serialize_field(&IdValue(&self.0))?;
    ts.end()
  }
}


trait TaskBuilder {
  fn build(self: Box<Self>) -> Box<dyn Task>;
}

struct StructBuilder<T>(fn(T) -> Box<dyn Task>, T);
impl<T> TaskBuilder for StructBuilder<T> {
  fn build(self: Box<Self>) -> Box<dyn Task> {
    self.0(self.1)
  }
}


pub struct DeserializeGeneric;
impl<'de> DeserializeSeed<'de> for DeserializeGeneric {
  type Value = bool;
  fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error> where D: Deserializer<'de> {
    deserializer.deserialize_map(self)
  }
}
impl<'de> Visitor<'de> for DeserializeGeneric {
  type Value = bool;
  fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error> where A: MapAccess<'de> {
    let Some(deserialize_fn) = map.next_key_seed(IdTGenericDeserializeFn)? else {
      return Err(de::Error::custom("nope B"));
    };
    map.next_value_seed(DeserializeWithFn(deserialize_fn))
  }
  fn expecting(&self, formatter: &mut Formatter) -> fmt::Result { write!(formatter, "nope A") }
}


// TODO: get deserialize function based on the id!

type GenericDeserializeFn = for<'de> fn(&mut dyn erased_serde::Deserializer<'de>) -> Result<Box<dyn TaskBuilder>, erased_serde::Error>;

struct IdTGenericDeserializeFn;
impl<'de> DeserializeSeed<'de> for IdTGenericDeserializeFn {
  type Value = GenericDeserializeFn;
  fn deserialize<D: Deserializer<'de>>(self, deserializer: D) -> Result<Self::Value, D::Error> {
    deserializer.deserialize_str(self)
  }
}
impl<'de> Visitor<'de> for IdTGenericDeserializeFn {
  type Value = GenericDeserializeFn;
  fn visit_str<E: de::Error>(self, _id: &str) -> Result<Self::Value, E> {
    todo!()
    // let f = |deserializer|{
    //   let bool = bool::deserialize(deserializer)?;
    //   StructBuilder()
    // };
    // Ok(f)
  }
  fn expecting(&self, formatter: &mut Formatter) -> fmt::Result { write!(formatter, "nope C") }
}

struct DeserializeWithFn(GenericDeserializeFn);
impl<'de> DeserializeSeed<'de> for DeserializeWithFn {
  type Value = bool;
  fn deserialize<D: Deserializer<'de>>(self, _deserializer: D) -> Result<Self::Value, D::Error> {
    //let mut erased = <dyn erased_serde::Deserializer>::erase(deserializer);
    //(self.0)(&mut erased).map_err(de::Error::custom)
    todo!()
  }
}


static TASK_REGISTRY: Lazy<Registry<dyn Task>> = Lazy::new(|| {
  let mut registry = Registry::<dyn Task>::new("Task");
  registry.register("Constant", |d: &mut dyn erased_serde::Deserializer| {
    struct ConstantVisitor;
    impl<'de> Visitor<'de> for ConstantVisitor {
      type Value = Box<dyn Task>;

      fn expecting(&self, formatter: &mut Formatter) -> fmt::Result { write!(formatter, "nope D") }

      fn visit_seq<A: SeqAccess<'de>>(self, mut seq: A) -> Result<Self::Value, A::Error> {
        let value = seq.next_element_seed(DeserializeGeneric)?.unwrap();
        Ok(Box::new(Constant(value)))
      }
    }

    // TODO: this now only serializes booleans, not correct obviously!
    let value = d.deserialize_tuple_struct("Constant", 1, ConstantVisitor)?;
    Ok(value)
  });
  registry
});

impl Serialize for dyn Task {
  fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
    serialize_trait_object(serializer, self.id(), self)
  }
}

impl<'de> Deserialize<'de> for Box<dyn Task> {
  fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
    deserialize_trait_object(deserializer, &TASK_REGISTRY)
  }
}


// Run serialization roundtrips

fn main() -> Result<(), Box<dyn Error>> {
  let constant_bool = Constant(true);

  { // `Box<dyn Task>` serialization roundtrip
    let task: Box<dyn Task> = Box::new(constant_bool);
    let json = serde_json::to_string(&task)?;
    println!("`Box<dyn Task>`   serialized: {}", json);

    let roundtrip: Box<dyn Task> = serde_json::from_str(&json)?;
    println!("`Box<dyn Task>` deserialized: {:?}", roundtrip);
  }

  Ok(())
}
